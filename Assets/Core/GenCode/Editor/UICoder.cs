using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using UnityEngine.Events;
using UnityEngine.Sprites;
using UnityEngine.Scripting;
using UnityEngine.Assertions;
using UnityEngine.EventSystems;
using UnityEngine.Assertions.Must;
using UnityEngine.Assertions.Comparers;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using BridgeUI;
using BridgeUI.NRefactory;
using BridgeUI.NRefactory.Ast;
//using BridgeUI.NRefactory.AstBuilder;
using BridgeUI.NRefactory.Parser;
using BridgeUI.NRefactory.Parser.CSharp;
using BridgeUI.NRefactory.PrettyPrinter;
using BridgeUI.NRefactory.Visitors;
using System.IO;
using System.Text;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
namespace BridgeUI
{
    public class UICoder
    {
        private string oldStr
        {
            get
            {
                return "// ------------------------------------------------------------------------------\r\n" +
    "//  <autogenerated>\r\n" +
    "//      This code was generated by a tool.\r\n" +
    "//      Mono Runtime Version: 2.0.50727.1433\r\n" +
    "// \r\n" +
    "//      Changes to this file may cause incorrect behavior and will be lost if \r\n" +
    "//      the code is regenerated.\r\n" +
    "//  </autogenerated>\r\n" +
    "// ------------------------------------------------------------------------------\r\n";
            }
        }
        private string newStr
        {
            get
            {
                return CalculateHead(Application.companyName, System.DateTime.Now.ToString("yyyy-MM-dd hh:mm:ss"),"本脚本由电脑自动生成","请尽量不要在其中写代码","更无法使用协程及高版本特性");
            }
        }
        public CodeCompileUnit unit { get; private set; }

        public UICoder()
        {
            unit = new CodeCompileUnit();
        }
        /// <summary>
        /// 从旧的脚本加载
        /// </summary>
        public void Load(string script)
        {
            using (var reader = new StringReader(script))
            {
                IParser parser = ParserFactory.CreateParser( reader);
                parser.Parse();
                CodeDomVisitor visit = new CodeDomVisitor();
                visit.VisitCompilationUnit(parser.CompilationUnit, null);
                unit = visit.codeCompileUnit;

                //CodeMemberMethod method = unit.Namespaces[0].Types[0].Members[7] as CodeMemberMethod;

                //Debug.Log(method.Name);
                //CodeExpressionStatement state = method.Statements[2] as CodeExpressionStatement;
                //CodeMethodInvokeExpression exp = state.Expression as CodeMethodInvokeExpression;
                //Debug.Log(exp.Parameters[0]);
            }
        }
        /// <summary>
        /// 编译代码
        /// </summary>
        /// <returns></returns>
        public string Compile()
        {
            CodeGeneratorOptions option = new CodeGeneratorOptions();
            option.BlankLinesBetweenMembers = true;
            CSharpCodeProvider provider = new CSharpCodeProvider();

            using (StringWriter sw = new System.IO.StringWriter())
            {
                provider.GenerateCodeFromCompileUnit(unit, sw, option);

                return sw.ToString().Replace(oldStr, newStr);
            }
        }


        private string CalculateHead(string author, string time, params string[] detailInfo)
        {
            var str1 =
               "/*************************************************************************************   \r\n" +
               "    * 作    者：       {0}\r\n" +
               "    * 时    间：       {1}\r\n" +
               "    * 说    明：       ";
            var str2 = "\r\n                       ";
            var str3 = "\r\n* ************************************************************************************/\r\n";

            var headerStr = string.Format(str1, author, time);
            for (int i = 0; i < detailInfo.Length; i++)
            {
                if (i == 0)
                {
                    headerStr += string.Format("{0}.{1}", i + 1, detailInfo[i]);
                }
                else
                {
                    headerStr += string.Format("{0}{1}.{2}", str2, i + 1, detailInfo[i]);
                }
            }
            headerStr += str3;
            return headerStr;
        }

    }
}